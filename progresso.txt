yarn init -y

yarn add express

criar pasta src
criar app, server e routes.js

criar o editorconfig
yarn add eslint prettier eslint-config-prettier eslint-plugin-prettier babel-eslint -D
yarn eslint --init

utilizar o sucrase para utilizar import
yarn add sucrase nodemon -D

adicionar nos scripts no package.json para rodar o nodemon sucrase
e junto a isso, para que funcione o sucrase, criamos o nodemon.json

Primeiro commit

docker run --name desafio -e POSTGRES_PASSWORD=desafio -p 5432:5432 -d postgres

parar acessar no postbird:
usuario postgres
senha desafio

criei banco de dados fastfeet no postbird

Criei o arquivo database na pasta config
Criar a pasta migrations
Colocar o .rcsequelizerc
Instalar sequelize

yarn add sequelize
yarn add sequelize-cli -D
yarn add pg pg-hstore

Segundo commit

Criando a migration de usuarios
yarn sequelize migration:create --name=create-users
Criei a migration de usuario de acordo com o modelo do git do seeds que ele da

yarn sequelize db:migrate

yarn add bcryptjs
yarn sequelize seed:generate --name admin-user

yarn sequelize db:seed:all

Terceiro commit

Criar pasta app
Criar pasta controllers
Criar pasta models

Criamos o User.js
Criamos o index na pasta database para conseguir fazer a conexao do model com o database
importar models no index js criado acima

import database no app.js

Crio uma rota no routes pra testar se o model esta funcionando
Testamos a rota e ainda podemos ver que foi criado no banco de dados o usuario

Criar o controller de users
Criar a rota de store no routes
Testamos no insomnia

Criar verificacao de email unico no controller
instalar o bcryptjs

Criamos o campo password virtual no model de usuario
Adicionar o hook no model para criar o password hash
Testar no insomnia

Quarto Commit

Criar autenticacao
Criar o controller SessionController
yarn add jsonwebtoken
Verificar se userexists no controller

Colocar a verificacao da senha dentro do model de usuario , pois nao eh uma regra de negocio, eh apenas
uma verificacao de senha

Retornar do sessioncontroller store o jwt junto com os dados de login
jwt = header(algoritmo utilizado para gerar este jwt).payload(pode conter dados nao sensiveis, tipo id e email).assinatura

jwd.sign(a,b, c)// payload, texto unico em toads as aplicacoes do universo md5online, informacoes
extras, tipo expiracao

Digitei paoloappfastfeedrocketseat

Criar a rota no routes
Criar o auth no config para separar a configuracao do jwt
fazer a importacao

Criar middleware de autenticacao
Criar pasta middleware e auth.js

Criar um metodo update no usuario simplesmente retornando ok
Criar a rota

Criar no insomnia uma requisicao de put com o Bearer no Header ou colocando autorhizaton
Terminar o middleware de auth e importar no routes

Jwt.verify tem as versos sincrona e assincrona
Mas a assincrona ela ainda utiliza callbacks
Com isso, utilizamos o promisify, que torna possivel a utilizacao de async e await para
funcoces que utilizam callbacks
Nao esquecer de deixasr o middleware async

Colocamos o userId no req, pois desta forma, todas as proximas requisicoes vao conter o id
do usuario, e com isso, saberemos que ele esta logado
Por exemplo, no caso de update, nao precisara enviar as informacoes de quem ele quer alterar,
ja que ele soh pode alterar ele mesmo.

Terminar o controller user update

yarn add yup

Fazer validacao no user controller para store e update
Podemos fazer tambem para o session, mas nao fiz

Quinto commit

Fiz a validacao pro SessionController

Sexto commit

yarn sequelize migration:create --name=create-recipients

yarn sequelize db:migrate

Pronto, criei a tabela de recipients

Setimo Commit

Criei model e controller de Recipient. Ta incompleto ainda. Mas ja fiz alguns cadastros no banco de dados.

Oitavo Commit

Fiz o metodo get e update do recipient
Fiz o metodo update do user
Testei tudo no insomnia

Nono Commit

